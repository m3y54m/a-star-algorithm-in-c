A* Algorithm Implementation in C
=================================

A very basic and easy to understand implementation of A* algorithm in C that was part of my "Fundamentals of Programming" course at the University of Zanjan, Fall 2012.

.. figure:: https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/output.png?raw=true
    :alt: Output of this code in terminal of linux

    Output of this code in terminal of linux

The code is written based on this tutorial: https://www.raywenderlich.com/3016-introduction-to-a-pathfinding

I (Meysam Parvizi) translated this tutorial into Persian/فارسی and published it my website (http://tabin.ir).
Now I decided to publish that article here as the README file of this repository:

.. raw:: html

    <div dir="rtl">
    <h1>آشنایی با الگوریتم مسیریابی *A</h1>
    <h2>مقدمه</h2>
    <p>این مقاله سعی دارد تا الگوریتم *A را که از این پس برای راحتی کار، آن را الگوریتم «آ-ستاره» می نامیم، گام به گام و بر اساس مفاهیم بسیار ابتدایی شرح دهد. ضمناً سعی کرده‌‌‌‌ایم که تنها به حروف و کلمات بسنده نکنیم و از تصاویر و نمودارها نیز برای انتقال مفاهیم کمک بگیریم.</p>
    <p>مهم نیست که شما می‌‌‌‌خواهید از کدام زبان برنامه‌‌‌‌نویسی برای پیاده‌‌‌‌سازی این الگوریتم استفاده کنید، کافی است گام به گام با ما پیش بیایید و فقط سعی کنید که الگوریتم «آ-ستاره» را کاملاً دقیق بفهمید.</p>
    <h2>گربه‌‌‌‌ی مسیریاب</h2>
    <p>تصور کنید که ما یک بازی داریم که در آن گربه‌‌‌‌ای می‌‌‌‌خواهد مسیری را برای رسیدن به یک تکه استخوان پیدا کند.</p>
    <p>شاید از خود بپرسید که یک گربه چرا باید به دنبال یک تکه استخوان باشد؟!</p>
    <p>خوب! گربه‌‌‌‌ی بازیِ ما بسیار زیرک است و می‌‌‌‌خواهد با جمع کردن استخوان‌‌‌‌ها و دادن آن‌‌‌‌ها به سگ‌‌‌‌ها، از چنگال آن‌‌‌‌ها در امان بماند!</p>
    <p>فرض کنید گربه‌‌‌‌ی موجود در شکل زیر می‌‌‌‌خواهد کوتاه‌‌‌‌ترین مسیر برای رسیدن به استخوان را پیدا کند:</p>
    <img class="wp-image-295 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A1.png?raw=true" alt="گربه‌‌‌‌ای در جستجوی استخوان" width="480" height="432" />
    <p>متأسفانه گربه نمی‌‌‌‌تواند مستقیماً از مکان فعلی خود به طرف استخوان حرکت کند، چون در مقابلش یک دیوار قرار دارد و گربه‌‌‌‌ی ما هم برخلاف ارواح نمی‏‌تواند از دیوار عبور کند!</p>
    <p>از طرف دیگر، گربه‌‌‌‌ی ما خیلی تنبل است و دوست دارد که کوتاه‌‌‌‌ترین راه را پیدا کند.</p>
    <p>اما چگونه می‌‌‌‌توانیم الگوریتمی بنویسیم که کوتاه‌‌‌‌ترین مسیر بین گربه و استخوان را پیدا کند؟ اینجاست که از «آ-ستاره» کمک می‌‌‌‌گیریم!</p>
    <h2>ساده کردن حوزه‌‌‌‌ی جستجو</h2>
    <p>در گام نخست باید حوزه‌‌‌‌ی جستجو را به چیزی که مدلسازی ریاضی آن آسان باشد نزدیک کنیم.</p>
    <p>مثلاً می‌‌‌‌توانیم حوزه‌‌‌‌ی جستجو را پیکسل‌‌‌‌بندی کنیم؛ اما در شرایط فعلی این کاملاً غیرضروری است و فقط کار ما را سخت می‌‌‌‌کند پس بهتر است به چیز ساده‌‌‌‌تری فکر کنیم مثلاً تقسیم‌‌‌‌بندی صفحه به مربع‌‌‌‌های هم اندازه و تا حد ممکن بزرگ. البته می‌‌‌‌توان واحدهای مختلفی برای تقسیم‌‌‌‌بندی صفحه (مثل مثلث یا شش‌‌‌‌‏ضلعی) به کار برد اما مربع آسان‌‌‌‌ترین و بهترین گزینه‌‌‌‌ای است که می‌‌‌‌توان برای این مسئله انتخاب کرد.</p>
    <p>با این تقسیم‌‌‌‌بندی می‌‌‌‌توانیم حوزه‌‌‌‌ی جستجو را تبدیل به یک آرایه‌‌‌‌ی دو بعدی کنیم که مانند یک نقشه از حوزه‌‌‌‌ی جستجو، همه چیز را در اختیار ما می‌‌‌‌گذارد. مثلاً اگر سطح یک مربع کاشی شده‌‌‌‌ی 25 در 25 را در نظر بگیریم، حوزه‌‌‌‌ی جستجوی ما یک آرایه‌‌‌‌ی دوبعدی متشکل از 625 کاشی مربعی‌‌‌‌شکل خواهد بود. حالا اگر در همین نقشه، بخواهیم از واحد پیکسل استفاده کنیم، حوزه‌‌‌‌ی جستجوی ما تبدیل به یک آرایه‌‌‌‌ی دوبعدی متشکل از 640000 مربع خواهد شد (با این فرض که ابعاد هر کاشی 32×32 پیکسل باشد)!</p>
    <p>بهتر است پس از تقسیم‌‌‌‌بندیِ مربعیِ حوزه‌‌‌‌ی جستجو نگاهی به آن بیندازیم که حالا به یک صفحه با (6×7 کاشی =) 42 کاشی مربعی‌‌‌‌شکل تبدیل شده است:</p>
    <img class="wp-image-296 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A2.png?raw=true" alt="تقسیم‌‌‌‌بندی مربعی حوزه‌‌‌‌ی جستجو" width="480" height="432" />
    <h2>لیست‌‌‌‌های باز و بسته</h2>
    <p>حالاً که حوزه‌‌‌‌ی جستجو را به شکل ساده‌‌‌‌تری درآوردیم، زمان بحث در مورد الگوریتم آ-ستاره رسیده است.</p>
    <p>گربه‌‌‌‌ی ما علاوه بر این که تنبل است، حافظه‌‌‌‌ی چندان خوبی هم ندارد، بنابر این ما به دو لیست نیاز داریم:</p>
    <p>یکی برای فهرست کردن تمام مربع‌‌‌‌هایی که تصور می‌‌‌‌شود کوتاه‌‌‌‌ترین مسیر را به دست دهند؛ که آن را <strong>لیست باز (</strong><strong>Open List</strong><strong>)</strong> می‌‌‌‌نامیم.</p>
    <p>دیگری برای فهرست کردن مربع‌‌‌‌هایی که دیگر لازم نیست مورد ارزیابی قرار گیرند که آن را <strong>لیست بسته (</strong><strong>Closed List</strong><strong>) </strong>می‌‌‌‌نامیم.</p>
    <p>گربه با اضافه کردن موقعیت فعلی‌‌‌‌اش به لیست بسته، کارش را شروع می‌‌‌‌کند. (ما نقطه‌‌‌‌ی شروع را A می‏‌نامیم.) سپس از میان مربع‌‌‌‌های همسایه‌‌‌‌اش (Adjucent Squares) ، آن‌‌‌‌هایی را که قابل تردد هستند به لیست باز اضافه می‌‌‌‌کند.</p>
    <p>این تصویر نمونه‌‌‌‌ای از چیزی است در بالا بیان شد، البته با این فرض که گربه در محیطی باز و بدون مانع قرار داشته باشد. (مربع‌‌‌‌های با حاشیه‌‌‌‌ی سبزرنگ همان لیستِ باز هستند):</p>
    <img class="wp-image-297 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A3.png?raw=true" alt="تمام انتخاب‌های ممکن برای گربه در مکان فعلی" width="480" height="432" />
    <p>حالا گربه باید مشخص کند که کدام یک از این مربع‌‌‌‌ها در کوتاه‌‌‌‌ترین مسیر قرار دارند. اما چگونه؟</p>
    <p>خوب، در الگوریتم آ-ستاره این کار با اختصاص دادن امتیاز به هر مربع انجام می‌‌‌‌پذیرد که به آن <strong>امتیازدهی مسیر (</strong><strong>Path Scoring</strong><strong>)</strong> گفته می‏شود.</p>
    <h2>امتیازدهی به مسیر</h2>
    <p>ما به هر مربع یک امتیاز که حاصل جمع G+H است، اختصاص می‌‌‌‌دهیم:</p>
    <h3>G</h3>
    <p>‌هزینه‌‌‌‌‌ی حرکت از نقطه‌‌‌‌ی شروع مسیر تا مکان فعلی است. با این حساب برای مربع همسایه‌‌‌‌ی نقطه‌‌‌‌ی A ، این مقدار برابر 1 خواهد بود و هرچقدر که از نقطه‌‌‌‌ی آغازِ حرکت دورتر شویم، مقدار G افزایش خواهد یافت.</p>
    <h3>H</h3>
    <p>تخمین ما از فاصله‌‌‌‌ی مربعی که اکنون در آن قرار داریم تا نقطه‌‌‌‌ی پایان مسیر (که از این پس آن را نقطه‌ی B می‏‌نامیم) است. این عدد لزوماً مقدار واقعی نیست چون ما هنوز مسیر را نپیموده‌‌‌‌ایم تا مقداد دقیق آن را بفهمیم بلکه فقط یک حدس است.</p>
    <p>شاید بپرسید که منظور از ‌<strong>هزینه</strong><strong>‌</strong><strong>‌‌‌‌</strong><strong>ی حرکت (</strong><strong>Movement Cost</strong><strong>)</strong> چیست؟ خوب، در این بازی ما بسیار ساده است – صرفاً تعداد مربع‌‌‌‌هایی است که از روی آن‌‌‌‌ها عبور کرده‌‏ایم.</p>
    <p>به هر حال باید به یاد داشته باشید که نحوه‌‌‌‌ی محاسبه‌‌‌‌ی G و H متناسب با شرایط بازی می‌‌‌‌تواند تغییر کند. مثلاً:</p>
    <ul>
    <li>اگر شما مجاز به حرکت‌‌‌‌های قطری (اُریب) باشید، باید ‌هزینه‌‌‌‌‌ی حرکت مربوط به حرکت‌‌‌‌های قطری را اندکی بیشتر از حرکت‌‌‌‌های مستقیم (بالا، چپ، پایین و راست) در نظر بگیرید.</li>
    <li>اگر در بازی شما عوارض و موانع طبیعی مختلفی وجود دارد باید ‌هزینه‌‌‌‌‌ی حرکت را برای عبور از باتلاق، دریاچه و هر مانعی که عبور از آن مشکل‌‌‌‌تر است، بیشتر در نظر بگیرید.</li>
    </ul>
    <p>این‌‌‌‌ها همگی مفاهیم کلّی بودند – حالا وقت دقیق شدن در جزئیات محاسبه‌‌‌‌ی G و H است.</p>
    <h2>درباره‌‌‌‌ی G بیشتر بدانید</h2>
    <p>به یاد بیاورید که G ‌هزینه‌‌‌‌‌ی حرکت (و به طور خاص در بازی ما، تعداد مربع‌‌‌‌های پیموده شده) از نقطه‌‌‌‌ی شروع حرکت یعنی A تا موقعیت کنونی است.</p>
    <p>برای محاسبه‌‌‌‌ی G در یک مکان خاص از مسیر، ما باید G مربوط به موقعیتِ <strong>والد (</strong><strong>Parent</strong><strong>)</strong> آن (یعنی آخرین مربعی که از آن گذشته‌‌‌‌ایم و به اینجا رسیده‌‌‌‌ایم) را در نظر بگیریم و یک واحد به آن اضافه کنیم. با این دستورالعمل، G مربوط به هر مربع، تعداد مربع‌‌‌‌هایی است که از نقطه‌‌‌‌ی شروع یعنی A تا موقعیت کنونی از روی آن‌‌‌‌ها عبور کرده‌‌‌‌ایم.</p>
    <p>به عنوان مثال، نمودار زیرین دو مسیر متفاوت را به سوی دو تکه استخوان متفاوت نشان می‌‌‌‌دهد که مقادیر G مربوط به هر مربع موجود در مسیر روی خود آن مربع نوشته شده است:</p>
    <img class="wp-image-298 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A4.png?raw=true" alt="مقادیر متوالی G در دو مسیر مختلف" width="480" height="432" />
    <h2>درباره‌‌‌‌ی H بیشتر بدانید</h2>
    <p>به یاد بیاورید که H ‌هزینه‌‌‌‌‌ی حرکت تخمینی (یعنی تعداد مربع‌‌‌‌های باقیمانده) از موقعیت فعلی تا نقطه‌‌‌‌ی پایان مسیر یعنی B است.</p>
    <p>هر چقدر که ‌هزینه‌‌‌‌‌ی حرکت تخمینی به اندازه‌‌‌‌ی واقعی نزدیک‌‌‌‌تر باشد، مسیر نهایی درست‌‌‌‌تر خواهد بود. اگر این مقدار تخمینی مورد استفاده قرار نگیرد، ممکن است مسیر نهایی کوتاه‌‌‌‌ترین مسیر نباشد (البته شاید نزدیک به آن باشد). این موضوع بسیار پیچیده است و از این رو در این مقاله پوشش داده نخواهد شد.</p>
    <p>برای این که کارمان را ساده کنیم از <strong>روش فاصله</strong><strong>‌‌‌‌</strong><strong>ی منهتن (</strong><strong>Manhattan distance method</strong><strong>)</strong> که با نام‌‌‌‌های <strong>طول منهتن (</strong><strong>Manhattan Length</strong><strong>)</strong> یا <strong>فاصله</strong><strong>‌‌‌‌</strong><strong>ی بلوک شهری (</strong><strong>City block distance</strong><strong>)</strong> هم شناخته می‌‌‌‌شود استفاده می‌‌‌‌کنیم. در این روش بدون در نظر گرفتن موانع و عوارض طبیعی موجود در مسیر، فقط فاصله‌‌‌‌ی افقی و عمودی از نقطه‌‌‌‌ی فعلی تا رسیدن به نقطه‌‌‌‌ی نهایی یعنی B را در نظر می‏‌گیریم.</p>
    <p>به عنوان مثال، تصویر زیر چگونگی استفاده از «فاصله‌‌‌‌ی بلوکی» را در محاسبه‌‌‌‌ی H نشان می‌‌‌‌دهد (که مقدار آن با رنگ سیاه در مربع مربوطه نوشته شده است):</p>
    <img class="wp-image-299 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A5.png?raw=true" alt="تخمین مقدار H با روش فاصله بلوکی" width="480" height="432" />
    <h2>الگوریتم آ-ستاره</h2>
    <p>حالا که متوجه شدید چگونه باید امتیاز هر مربع را محاسبه کنیم (که از این به بعد آن را F می‌‌‌‌نامیم و برابر با G+H است)، وقت آن است که ببینیم الگوریتم آ-ستاره چگونه کار می‌‌‌‌کند.</p>
    <p>گربه‌‌‌‌ی ما کوتاه‌‌‌‌ترین مسیر را با تکرار کردن مراحل زیر پیدا خواهد کرد:</p>
    <ol>
    <li><strong> مربعی که کم</strong><strong>‌‌‌‌</strong><strong>ترین امتیاز را در لیست باز دارد را در نظر می</strong><strong>‌‌‌‌</strong><strong>گیریم. از این پس این مربع را </strong><strong>S</strong><strong> می</strong><strong>‌‌‌‌</strong><strong>نامیم.</strong></li>
    <li><strong>S</strong><strong> را از لیست باز حذف می</strong><strong>‌‌‌‌</strong><strong>کنیم و به لیست بسته اضافه می</strong><strong>‌‌‌‌</strong><strong>کنیم.</strong></li>
    <li><strong> به ازای هر مربعِ </strong><strong>T</strong><strong> که در همسایگی </strong><strong>S</strong><strong> قرار دارد:</strong></li>
    <li>اگر T در لیستِ بسته است: آن را نادیده بگیر. (کاری به کارش نداشته باش.)</li>
    <li>اگر T در لیستِ باز نیست: آن را به لیست باز اضافه کن و امتیازش (F) را محاسبه کن.</li>
    <li>اگر T در لیستِ باز است: بررسی کن که با در نظر گرفتن S به عنوان موقعیت والد و محاسبه‌‌‌‌ی مجددِ G ، آیا امتیازِ F آن کاهش می‌‌‌‌یابد؟ اگر پاسخ مثبت است، امتیاز آن را به روز کن و موقعیتِ والد آن را نیز به روز کن.</li>
    </ol>
    <p>اگر هنوز هم کمی سردرگم هستید، نگران نباشید چون از این پس با یک مثال و گام به گام پیش خواهیم رفت تا نحوه‌‌‌‌ی عملکرد این الگوریتم را عیناً مشاهده کنید!</p>
    <h2>مسیر گربه</h2>
    <p>بگذارید با همان مثالِ گربه‌‌‌‌ی تنبل خودمان و مسیرش به سوی تکه استخوان پیش برویم.</p>
    <p>در نمودارهای زیر، مقادیرِ F = G + H مطابق با نکات زیر داخل هر مربع نوشته شده‌‌‌‌اند:</p>
    <p><strong>F</strong><strong> (امتیاز مربع مربوطه): گوشه</strong><strong>‌‌‌‌</strong><strong>ی چپ و بالا</strong></p>
    <p><strong>G</strong><strong> (مسافت پیموده شده از </strong><strong>A</strong><strong> تا مربع مربوطه): گوشه</strong><strong>‌‌‌‌</strong><strong>ی چپ و پایین</strong></p>
    <p><strong>H</strong><strong> (مسافت تخمینی از مربع مربوطه تا </strong><strong>B</strong><strong>): گوشه</strong><strong>‌‌‌‌</strong><strong>ی راست و پایین</strong></p>
    <p>همچنین، پیکان‌‌‌‌های موجود در هر مربع، جهت حرکتی که برای رفتن به آن مربع نیاز است را نشان می‌‌‌‌دهد.</p>
    <p>در نهایت، در هر مرحله، مربع‌‌‌‌های سرخ‌‌‌‌رنگ نشان دهنده‌‌‌‌ی موارد موجود در <strong>لیست بسته</strong> هستند و مربع‌‌‌‌های سبزرنگ نشان دهنده‌‌‌‌ی موارد موجود در <strong>لیست باز</strong> هستند.</p>
    <p>بسیار خوب، حالا شروع می‌‌‌‌کنیم:</p>
    <h3>گام اوّل</h3>
    <p>در گام اوّل، گربه‌‌‌‌ی ما از میان مربع‌‌‌‌های مجاورِ مکان کنونی یعنی A ، مربع‌‌‌‌هایی را که مسدود نیستند شناسایی کرده و امتیازِ F آن‌‌‌‌ها را محاسبه می‌‌‌‌کند و سپس آن‌‌‌‌ها را به لیست باز اضافه می‌‌‌‌کند:</p>
    <img class="wp-image-300 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A6.png?raw=true" alt="گام اول" width="480" height="432" />
    <p>در شکل بالا می‏‌ببینید که مقدار H برای هر مربع نوشته شده است (دو تا از آن‌‌‌‌ها 6 هستند و یکی 4). من پیشنهاد می‌‌‌‌کنم که از همان روش شمارش مربع‌‌‌‌ها با توجه به «فاصله‌‌‌‌ی بلوکی» استفاده کنید تا متوجه شوید که چگونه H را محاسبه کرده‏ایم.</p>
    <p>همچنین توجه داشته باشید که مقدارِ F (در گوشه‌‌‌‌ی چپ و بالا) صرفاً حاصل جمع G+H است (که در گوشه‌‌‌‌های پایینی نوشته شده‌‌‌‌اند.)</p>
    <h3>گام دوم</h3>
    <p>در گام بعدی، گربه‌‌‌‌ی ما مربعی که کم‌‌‌‌ترین مقدار F را دارد، انتخاب کرده و آن را به لیست بسته اضافه می‌‌‌‌کند، از لیست باز حذف می‌‌‌‌کند و مربع‌‌‌‌های مجاور این مربع جدید (که کم‌‌‌‌ترین F را داشته است) را شناسایی می‌‌‌‌کند.</p>
    <img class="wp-image-301 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A7.png?raw=true" alt="گام دوم" width="480" height="432" />
    <p>مربعی که کمترین امتیاز را دارد همان مربعی است که مقدارِ F آن برابر 5 است. گربه تلاش می‌‌‌‌کند که تمام مربع‌‌‌‌های مجاور را به لیستِ باز اضافه کند (و امتیاز آن‌‌‌‌ها را محاسبه کند)، اما باید توجه داشته باشید که او نمی‌‌‌‌تواند مکان قبلی خودش را (که هم اکنون در لیستِ بسته قرار دارد) یا موانع موجود در مسیر مانند مربع‌‌‌‌های هاشور خورده را (که قابل تردد نیستند) به لیست باز اضافه کند.</p>
    <p>توجه کنید که برای مربع‌‌‌‌های جدیدی که به لیست باز افزوده می‌‌‌‌شوند، مقدارِ G به اندازه‌‌‌‌ی یک واحد افزایش پیدا می‌‌‌‌کند چون این مربع‌‌‌‌ها به اندازه‏ی 2 کاشی با نقطه‌‌‌‌ی شروع فاصله دارند. برای اطمینان از مقدار H هم می‌‌‌‌توانید از شمارش «فاصله‌‌‌‌ی بلوکی» استفاده کنید.</p>
    <h3>گام سوم</h3>
    <p>دوباره مربعی که کمترین مقدار F (یعنی 5) را داراست انتخاب کرده و روند پیشین را تکرار می‌‌‌‌کنیم:</p>
    <img class="wp-image-302 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A8.png?raw=true" alt="گام سوم" width="480" height="432" />
    <p>در این مرحله تنها یک کاشی می‌‌‌‌تواند به لیست باز اضافه شود، چون دوتا از کاشی‌‌‌‌های همسایه مسدود هستند و یکی هم در لیستِ بسته قرار دارد.</p>
    <h3>گام چهارم</h3>
    <p>حالا با یک وضعیت جالب مواجه شده‌‌‌‌ایم. همان‌‌‌‌گونه که در گام سوم مشاهده کردید، 4 مربع با مقدارِ F یکسان (یعنی 7) موجودند؛ الآن چه باید کرد؟!</p>
    <p>راه حل‌‌‌‌های مختلفی برای این وضعیت وجود دارد اما ساده‌‌‌‌ترین و در عین حال سریع‌‌‌‌ترین راه این است که آخرین مربعی که به لیستِ باز اضافه شده است را برای حرکت بعدی انتخاب کنیم:</p>
    <img class="wp-image-303 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A9.png?raw=true" alt="گام چهارم" width="480" height="432" />
    <p>این بار دو کاشی قابل تردد در همسایگی وجود دارند که امتیاز آن‌‌‌‌ها را حساب می‌‌‌‌کنیم.</p>
    <h3>گام پنجم</h3>
    <p>دوباره مربعی که کمترین مقدار F (یعنی 7) را داراست و آخر از همه به لیستِ باز افزوده شده است انتخاب می‌‌‌‌کنیم:</p>
    <img class="wp-image-304 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A10.png?raw=true" alt="گام پنجم" width="480" height="432" />
    <p>در این مرحله فقط یک مربعِ قابلِ تردد به لیست باز اضافه می‌‌‌‌شود. کم کم به استخوان نزدیک می‌‌‌‌شویم!</p>
    <h3>گام ششم</h3>
    <p>دیگر خودتان روند کار را یاد گرفته‌‌‌‌اید! مطمئنم که می‌‌‌‌توانید گام بعدی را حدس بزنید:</p>
    <img class="wp-image-305 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A11.png?raw=true" alt="گام ششم" width="480" height="432" />
    <p>تقریباً رسیده‌‌‌‌ایم، امّا این بار مشاهده می‌‌‌‌کنید که دو مسیر وجود دارد که هر دو طول یکسانی دارند و کوتاه‌‌‌‌ترین مسیر هستند.  می‌‌‌‌توانیم یکی از آن‌‌‌‌ها را انتخاب کنیم تا به استخوان برسیم:</p>
    <img class="wp-image-306 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A12.png?raw=true" alt="دو مسیر متفاوت با طول یکسان" width="479" height="432" />
    <p>در مثال ما 2 مسیر مختلف به عنوان کوتاه‌‌‌‌ترین مسیر وجود دارند:</p>
    <p>6 – 5 – 4 – 3 – 2 – 1</p>
    <p>7 – 5 – 4 – 3 – 2 – 1</p>
    <p>فرقی نمی‌‌‌‌کند که کدام‌‌‌‌یک از آن‌‌‌‌ها را انتخاب کنیم، این موضوع باید در پیاده‌سازی الگوریتم هنگام کدنویسی در نظر گرفته شود.</p>
    <h3>گام هفتم</h3>
    <p>بگذارید مسیر را از طریق یکی از این دو مربع ادامه دهیم:</p>
    <img class="wp-image-307 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A13.png?raw=true" alt="گام هفتم" width="480" height="432" />
    <p>حالا استخوان در لیستِ باز است!</p>
    <h3>گام هشتم</h3>
    <p>در وضعیتی که استخوان (نقطه‌‌‌‌ی مقصد) در لیست باز قرار گیرد، الگوریتم آن را به لیستِ بسته اضافه می‌‌‌‌کند:</p>
    <img class="wp-image-308 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A14.png?raw=true" alt="گام هشتم" width="480" height="432" />
    <p>سپس تنها کاری که الگوریتم باید انجام دهد این است به عقب برگردد و مسیر نهایی را شناسایی کند.</p>
    <img class="wp-image-309 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A15.png?raw=true" alt="مسیر نهایی" width="480" height="432" />
    <h2>یک گربه‌‌‌‌ی معمولی</h2>
    <p>در مثال فوق، ما می‌‌‌‌بینیم که وقتی گربه به دنبال کوتاه‌‌‌‌ترین مسیر می‌‌‌‌گشت، غالباً بهترین مربع را انتخاب می‌‌‌‌کرد (آن مربعی که در راستای کوتاه‌‌‌‌ترین مسیرِ آینده‌‌‌‌اش قرار داشت) – گویا گربه‌‌‌‌ی ما می‏‌توانست آینده را پیش‏بینی کند.</p>
    <p>اما چه می‌‌‌‌شد اگر گربه‌‌‌‌ی ما نمی‌‌‌‌توانست آینده را ببیند و همواره اوّلین مربعی را که به لیست اضافه می‌‌‌‌شد انتخاب می‌‌‌‌کرد؟</p>
    <p>شکل زیر نشان می‌‌‌‌دهد که اگر چنین فرایندی را طی می‌‌‌‌کردیم باید چه مربع‌‌‌‌هایی را مورد بررسی قرار می‌‌‌‌دادیم. شما مشاهده می‌‌‌‌کنید که در این حالت گربه‌‌‌‌ی ما مربع‌‌‌‌های بیشتری را امتحان می‌‌‌‌کند، امّا باز هم کوتاه‌‌‌‌ترین مسیر را پیدا می‌‌‌‌کند (نه دقیقاً همان مسیری که قبلاً پیدا کرده بود امّا مسیر دیگری با طول یکسان پیدا می‌‌‌‌کند):</p>
    <img class="wp-image-310 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A16.png?raw=true" alt="پیدا کردن مسیر بدون انتخاب بهترین مربع‌ها" width="479" height="432" />
    <p>مربع‌‌‌‌های سرخ‌‌‌‌رنگ در نمودار فوق لزوماً کوتاه‌‌‌‌ترین مسیر را نشان نمی‌‌‌‌دهند، آن‌‌‌‌ها فقط مربع‌‌‌‌هایی را نشان می‌‌‌‌دهند که در مراحل مختلف به عنوانِ مربعِ S در نظر گرفته شده‌‌‌‌اند.</p>
    <p>من توصیه می‌‌‌‌کنم که به نمودار بالایی نگاه کنید و سعی کنید که همگام با آن پیش بروید. این بار در هر چندراهی، «بدترین» مسیر را برای رفتن انتخاب کنید. خواهید دید که باز هم با پیمودن کوتاه‌‌‌‌ترین مسیر به انتها می‌‌‌‌رسید!</p>
    <p>شما می‌‌‌‌بینید که اگر مربعِ «اشتباه» را دنبال کنید، مشکلی پیش نمی‌‌‌‌آید و شما با کوتاه‌‌‌‌ترین مسیر به انتها می‌‌‌‌رسید هرچند که باید روند الگوریتم را بیشتر تکرار کنید.</p>
    <p>در هنگام اجرای الگوریتم، مربع‌‌‌‌ها را با توجه به الگوریتم زیر به لیستِ باز اضافه می‌‌‌‌کنیم:</p>
    <p>مربع‌‌‌‌های همسایه به این ترتیب در نظر گرفته می‌‌‌‌شوند:</p>
    <p><strong>بالا / چپ / پایین / راست</strong> (البته شما می‌توانید ترتیب دیگری انتخاب کنید!)</p>
    <p>یک مربع پس از تمام مربع‌‌‌‌هایی که امتیاز یکسانی با آن دارند به لیستِ باز افزوده می‌‌‌‌شود (بنابر این اوّلین مربعی که اضافه می‌‌‌‌شود اولّین مربعی است که گربه انتخاب می‌‌‌‌کند).</p>
    <p>این یک نمودار برای عقب‌‌‌‌گرد و بازخوانی مسیر است:</p>
    <img class="wp-image-311 size-full" src="https://github.com/m3y54m/a-star-algorithm-in-c/blob/main/images/A17.png?raw=true" alt="بازخوانی مسیر" width="480" height="432" />
    <p>کوتاه‌‌‌‌ترین مسیر با شروع از نقطه‌‌‌‌ی مقصد و عقب رفتن از یک مربع والد به مربع والد دیگر ساخته می‌‌‌‌شود (مثلاً: در مربعِ مقصد می‌‌‌‌بینیم که پیکانِ داخلِ آن به سمت راست است پس مربعِ والد آن در سمت چپ قرار دارد).</p>
    <p>برای نتیجه‌‌‌‌گیری می‌‌‌‌توانیم فرایندی را که گربه طی می‌‌‌‌کند در قالب کد زیر خلاصه کنیم. کدهای زیر به زبان Objective-C هستند، امّا شما می‌‌‌‌توانید آن‌‌‌‌ها را به راحتی به هر زبان دیگری ترجمه کنید:</p>
    </div>
   
.. code-block:: objective-c
 
    [openList add:originalSquare]; // start by adding the original position to the open list

    do {
        currentSquare = [openList squareWithLowestFScore]; // Get the square with the lowest F score
        [closedList add:currentSquare]; // add the current square to the closed list
        [openList remove:currentSquare]; // remove it to the open list

        if ([closedList contains:destinationSquare]) { // if we added the destination to the closed list, we've found a path
                // PATH FOUND
                break; // break the loop
        }

        adjacentSquares = [currentSquare walkableAdjacentSquares]; // Retrieve all its walkable adjacent squares

        foreach (aSquare in adjacentSquares) {
                if ([closedList contains:aSquare]) { // if this adjacent square is already in the closed list ignore it
                        continue; // Go to the next adjacent square
                }

                if (![openList contains:aSquare]) { // if its not in the open list
                        // compute its score, set the parent
                        [openList add:aSquare]; // and add it to the open list
                } else { // if its already in the open list
                        // test if using the current G score make the aSquare F score lower, if yes update the parent because it means its a better path
                }
        }
    } while(![openList isEmpty]); // Continue until there is no more available square in the open list (which means there is no path)